---
layout: post
title: "[문제해결] 커머스 재고 동시성 문제를 겪으며"
description: 프로모션 세일 공동구매 커머스 플랫폼에서
date: 2021-07-01 17:01:28 -0400
tags: []
categories: [문제해결과정]
---

# 커머스 재고 트랜잭션 동시성 처리 

![Banner](https://www.bindcommerce.com/images/funzioni/inventory-sync2.jpg)
> 주문 요청이 급작스럽게 늘어나는 상황에서 재고 동시성 문제 발생


## **문제**

- MNGshop에서 특정 대학 중심의 공동구매 프로모션을 진행하면서 트래픽이 평소 대비 400% 급증하는 상황이 발생했음.
- 특히 아수스 노트북 3종을 판매했던 부산대 프로모션에서는 동시에 많은 사용자가 동일 상품을 구매하면서 재고 관리의 정확성 문제가 발생했음.
- 동시성 문제가 제대로 처리되지 않을 경우 품절된 상품이 판매되거나, 공급사에 잘못된 발주 수량이 전달되는 등의 문제가 발생할 수 있었음.

---

## **원인**

- **동시성 경합 문제**: 사용자들이 동시에 같은 상품을 결제 프로세스에 진입시키면서 재고 조회-차감 과정에서 시간차로 인한 데이터 불일치가 발생할 수 있었음.
- **트랜잭션 범위 설정의 문제**: 재고 확인부터 결제 완료까지 여러 단계가 존재하는데, 각 단계별 트랜잭션 처리가 명확하지 않으면 중간에 오류 발생 시 데이터 정합성이 깨질 수 있었음.
- **검증 로직 부재**: 재고 상태를 여러 단계에서 재확인하지 않으면, 결제 과정 중 다른 사용자가 재고를 선점할 경우 대응이 어려울 수 있었음.

---

## **대안**

- **메시지 큐 도입**: 주문 처리를 비동기 큐로 전환하여 순차적으로 처리하는 것이 일반적인 대안.
    - `문제 및 한계` :  스타트업 환경에서 인프라 구축 비용 및 복잡성 증가, 개발 리소스 부족, 즉각적인 주문 확인 요구사항과 맞지 않아 채택하지 못했음.
- **분산 락 시스템**: Redis 기반 분산 락을 구현하는 방안도 업계 표준 접근법.
    - `문제 및 한계` :  새로운 인프라 도입에 따른 학습 비용, 운영 부담, 기존 시스템과의 통합 복잡성을 고려했을 때 현 단계에서는 과도한 해결책이라 판단했음.
- **Sharding 기반 접근**: 상품별로 DB를 분리하는 방식
    - `문제 및 한계` :  상품 수가 제한적이었고 이미 구축된 백오피스 시스템과의 호환성 문제, 쿼리 복잡도 증가 등의 한계로 적용하지 않았음.

---

## **해결**

- **InnoDB의 트랜잭션 격리 수준과 행 수준 락 최적화**
    
    > - `SELECT FOR UPDATE` 구문을 활용하여 재고 조회와 동시에 해당 상품 레코드에 배타적 락을 걸어 데이터 일관성을 보장했음.
    - 재고 관련 쿼리에 대한 인덱스를 최적화하여 락 획득 속도를 개선하고 경합을 줄였음.
    > 
    > 
    > ```sql
    > CREATE INDEX idx_products_id_stock ON products(product_id, stock_quantity)
    > ```
    > 
    > - 특정 상품 레코드만 락이 걸리도록 하여 다른 상품 주문에는 영향을 주지 않도록 했음.
    > 
    > ```sql
    > ... WHERE product_id = :id FOR UPDATE
    > ```
    > 
- **계층적 트랜잭션 설계**:
    
    > 결제 전체 프로세스를 포괄하는 큰 트랜잭션과 내부 단계별 작은 트랜잭션을 병행하여, 결제 실패 시 자동 롤백되면서도 트랜잭션 유지 시간을 최소화했음.
    > 
- **다중 검증 메커니즘 구현**:
    
    > - 프론트엔드에서의 초기 검증, 백엔드 API 단계에서의 검증, 서비스 로직 단계에서의 검증, 그리고 DB 업데이트 단계에서의 WHERE 조건 검증까지 여러 단계에서 재고를 지속적으로 확인했음.
    > 
    > 
    > - DB 업데이트 시 조건절을 활용해 재고가 충분할 때만 업데이트가 발생하도록 구현
    > 
    > ```sql
    > UPDATE products SET stock = stock - :quantity 
    > WHERE product_id = :id AND stock >= :quantity
    > ```
    > 
- **결제 프로세스 최적화**
    
    > - 사용자가 결제 페이지에 접속할 때 재고를 임시로 선점하고, 일정 시간 내 결제를 완료하지 않으면 자동 해제되는 메커니즘을 구현했음.
    - 외부 결제 시스템 연동 시 타임아웃 처리를 추가하여, 결제 프로세스가 특정 시간 내에 완료되지 않으면 자동으로 롤백되도록 구현했음.
    > 

---

### **고찰**

이 방식을 통해 다음과 같은 성과를 얻었습니다.

1. **재고 데이터 정합성 유지**: 트래픽 급증 상황에서도 실제 재고와 시스템상 재고의 불일치가 발생하지 않았습니다.
2. **고객 경험 향상**: 주문 후 품절 통보와 같은 부정적 경험을 방지하여 고객 만족도를 높였습니다.
3. **오버셀링 방지**: 공급사에게 정확한 발주 수량을 전달할 수 있어 공급망 관리의 신뢰성을 확보했습니다.
4. **시스템 성능 유지**: 트랜잭션 최적화와 인덱스 개선으로 증가한 트래픽에도 시스템 응답성이 유지되었습니다.

이 경험을 통해 얻은 가장 큰 인사이트는 다음과 같습니다.

> 복잡한 분산 시스템을 도입하지 않더라도, 기존 RDBMS의 트랜잭션 기능과 락 매커니즘을 깊이 이해하고 최적화하면서 비즈니스 로직 수준에서 다중 검증 과정을 구현하는 것만으로도 중소 규모 커머스의 동시성 문제를 효과적으로 해결할 수 있다는 점. 이는 '오버엔지니어링 없이 실질적인 문제 해결에 집중한다'는 실용적인 엔지니어링 접근법의 중요성을 깨닫게 해줬습니다.
> 

> 또한, 재고 관리, 결제 처리, 주문 생성 등의 전체 프로세스를 하나로 보는 시각보다는, 각 단계별로 데이터 정합성을 검증하는 방어적 프로그래밍 방식이 안정적인 시스템 구축에 중요하다는 점을 배웠습니다.
>